$event = [Threading.EventWaitHandle]::OpenExisting("<%= output_ready_event_name %>")
if ($runspace -eq $null)
{
  $runspace = [RunspaceFactory]::CreateRunspace()
  $runspace.Open()
}

$powershell_code = @'
<%= powershell_code %>
'@
$ps = $null

try
{
  # http://learn-powershell.net/2012/05/13/using-background-runspaces-instead-of-psjobs-for-better-performance/
  $ps = [powershell]::create()
  $ps.Runspace = $runspace
  [Void]$ps.AddScript($powershell_code)

  $asyncResult = $ps.BeginInvoke()

  if (!$asyncResult.AsyncWaitHandle.WaitOne(<%= timeout_ms %>, $false))
  {
    throw "Catastrophic failure: PowerShell DSC resource timeout (<%= timeout_ms %> ms) exceeded while executing"
  }

  $output = $ps.EndInvoke($asyncResult)
  Write-Output $output
}
catch
{
  try
  {
    if ($runspace) { $runspace.Dispose() }
  }
  finally
  {
    $runspace = $null
  }
  @{
    indesiredstate = $false
    rebootrequired = $false
    errormessage = $_.Exception.Message
  } | ConvertTo-Json -Compress
}
finally
{
  [Void]$event.Set()
  [Void]$event.Dispose()
  if ($ps -ne $null) { [Void]$ps.Dispose() }
}

# always need a trailing newline to ensure PowerShell parses code
